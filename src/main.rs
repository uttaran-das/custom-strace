use std::{
    env,
    os::unix::process::CommandExt,
    process::{exit, Command},
};

use nix::{
    libc,
    sys::{
        ptrace,
        signal::Signal,
        wait::{waitpid, WaitStatus},
    },
    unistd::Pid,
};

#[cfg(target_arch = "x86_64")]

use syscalls::Sysno;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let args: Vec<String> = env::args().collect();

    if args.len() < 2 {
        eprintln!("Usage: {} <executable> [args]", args[0]);
        exit(1);
    }

    let target_executable = &args[1];
    let target_args = &args[2..];

    // {:?} is a placeholder for displaying a value using its Debug trait (developer-friendly, shows structure).
    println!(
        "---> Running command: {} {:?}",
        target_executable, target_args
    );

    let mut cmd = Command::new(target_executable);
    cmd.args(target_args);

    // The code is wrapped in an unsafe block because ptrace is a low-level system call that can violate Rust's safety guarantees if misused.
    unsafe {
        // This runs after fork() but before exec() in Unix terms.
        cmd.pre_exec(|| {
            ptrace::traceme().map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e))
        });
    }

    // Spawn the child process
    // `spawn()` starts the child but doesn't wait for it yet.
    // It returns a Result<Child, io::Error>.
    let mut child = cmd.spawn().expect("Failed to spawn child.");
    let child_pid = Pid::from_raw(child.id() as i32);

    eprintln!("---> Spawned child with PID: {}", child_pid);

    match waitpid(Some(child_pid), None) {
        // None options = wait for any state change
        Ok(WaitStatus::Stopped(pid, Signal::SIGTRAP)) => {
            // This is the expected stop after PTRACE_TRACEME + execve
            eprintln!(
                "---> Child {} stopped for initial trace setup. Setting options...",
                pid
            );
            // PTRACE_O_TRACESYSGOOD makes syscalls traps deliver (SIGTRAP | 0x80)
            ptrace::setoptions(pid, ptrace::Options::PTRACE_O_TRACESYSGOOD)?;
            eprintln!("---> Options set. Continuing child...");
        }
        Ok(status) => {
            eprintln!(
                "!!! Initial waitpid failed: Expected SIGTRAP, got {:?}",
                status
            );
            let _ = child.kill();
            exit(1);
        }
        Err(e) => {
            eprintln!("!!! Initial waitpid failed. {}", e);
            let _ = child.kill();
            exit(1);
        }
    }

    // Main tracing loop

    let mut is_entering_syscall = true; // Flag to track entry/exit
    loop {
        // Tell the kernel to continue the child but stop at the next syscall entry or exit
        if let Err(e) = ptrace::syscall(child_pid, None) {
            eprintln!("!!! ptrace::syscall failed: {}", e);
            // Check if the process still exists
            if let nix::errno::Errno::ESRCH = e {
                // ESRCH stands for "No such process."
                eprintln!("---> Child process {} seems to have exited.", child_pid);
                break;
            }
            let _ = child.kill();
            return Err(e.into()); // Error propagation
        }

        // Wait for the child to stop again
        let wait_status = match waitpid(child_pid, None) {
            Ok(status) => status,
            Err(e) => {
                eprintln!("!!! waitpid failed during loop: {}", e);
                if let nix::errno::Errno::ESRCH = e {
                    eprintln!("---> Child process {} seems to have exited.", child_pid);
                    break;
                }
                let _ = child.kill();
                return Err(e.into());
            }
        };

        match wait_status {
            // Did the child exit?
            WaitStatus::Exited(pid, status) => {
                eprintln!("---> Child {} exited with status {}", pid, status);
                break;
            }
            // Was the child terminated by a signal?
            WaitStatus::Signaled(pid, signal, core_dumped) => {
                eprintln!(
                    "---> Child {} terminated by signal {} (core_dumped={})",
                    pid, signal, core_dumped
                );
                break;
            }
            // Stopped due to a signal
            WaitStatus::Stopped(pid, signal) => {
                // Checking if it's the specific signbal generated by PTRACE_O_TRACESYSGOOD
                let is_syscall_trap = signal as i32 == (libc::SIGTRAP | 0x80);

                if is_syscall_trap {
                    // It's a syscall entry or exit stop
                    #[cfg(target_arch = "x86_64")] // Only compile this block for x86_64
                    {
                        // Get the register values
                        match ptrace::getregs(pid) {
                            Ok(regs) => {
                                if is_entering_syscall {
                                    // syscall entry
                                    // syscall number is in orig_rax on x86_64
                                    let syscall_no = regs.orig_rax as usize; // Convert to usize first
                                    if let Some(syscall) = Sysno::new(syscall_no) {
                                        eprintln!("[PID {}] > SYSCALL ENTRY: {}({:#x}, {:#x}, {:#x}, {:#x}, {:#x}, {:#x})", 
                                            pid, 
                                            syscall.name(),  // Now we can call name() on the unwrapped Sysno
                                            regs.rdi, 
                                            regs.rsi, 
                                            regs.rdx, 
                                            regs.r10, 
                                            regs.r8, 
                                            regs.r9
                                        );
                                    } else {
                                        eprintln!("[PID {}] > SYSCALL ENTRY: UNKNOWN({})({:#x}, {:#x}, {:#x}, {:#x}, {:#x}, {:#x})", 
                                            pid, 
                                            syscall_no,  // Print the raw syscall number if unknown
                                            regs.rdi, 
                                            regs.rsi, 
                                            regs.rdx, 
                                            regs.r10, 
                                            regs.r8, 
                                            regs.r9
                                        );
                                    }
                                } else {
                                    // syscall exit
                                    let ret_val = regs.rax;
                                    eprintln!(
                                        "[PID {} < SYSCALL EXIT: returning {:#x} ({})]",
                                        pid, ret_val, ret_val as i64
                                    );
                                }
                                is_entering_syscall = !is_entering_syscall;
                            }
                            Err(e) => {
                                eprintln!("!!! ptrace: getregs failed: {}", e);
                                if let nix::errno::Errno::ESRCH = e {
                                    eprintln!("---> Child process {} seems to have exited during getregs.", pid);
                                    break;
                                }
                            }
                        }
                    }

                    #[cfg(not(target_arch = "x86_64"))]
                    {
                        eprintln!("[PID {}] Syscall trap on unsupported architechture", pid);
                        is_entering_syscall = !is_entering_syscall;
                    }
                } else {
                    eprintln!("[PID {}] Stopped by signal: {}", pid, signal);
                }
            }
            // Handle PtraceSyscall status
            WaitStatus::PtraceSyscall(pid) => {
                #[cfg(target_arch = "x86_64")]
                {
                    match ptrace::getregs(pid) {
                        Ok(regs) => {
                            if is_entering_syscall {
                                let syscall_no = regs.orig_rax as usize;
                                if let Some(syscall) = Sysno::new(syscall_no) {
                                    eprintln!("[PID {}] > SYSCALL ENTRY: {}({:#x}, {:#x}, {:#x}, {:#x}, {:#x}, {:#x})", 
                                        pid, 
                                        syscall.name(),
                                        regs.rdi, 
                                        regs.rsi, 
                                        regs.rdx, 
                                        regs.r10, 
                                        regs.r8, 
                                        regs.r9
                                    );
                                } else {
                                    eprintln!("[PID {}] > SYSCALL ENTRY: UNKNOWN({})({:#x}, {:#x}, {:#x}, {:#x}, {:#x}, {:#x})", 
                                        pid, 
                                        syscall_no,
                                        regs.rdi, 
                                        regs.rsi, 
                                        regs.rdx, 
                                        regs.r10, 
                                        regs.r8, 
                                        regs.r9
                                    );
                                }
                            } else {
                                let ret_val = regs.rax;
                                eprintln!(
                                    "[PID {} < SYSCALL EXIT: returning {:#x} ({})]",
                                    pid, ret_val, ret_val as i64
                                );
                            }
                            is_entering_syscall = !is_entering_syscall;
                        }
                        Err(e) => {
                            eprintln!("!!! ptrace: getregs failed: {}", e);
                            if let nix::errno::Errno::ESRCH = e {
                                eprintln!("---> Child process {} seems to have exited during getregs.", pid);
                                break;
                            }
                        }
                    }
                }
                #[cfg(not(target_arch = "x86_64"))]
                {
                    eprintln!("[PID {}] Syscall trap on unsupported architecture", pid);
                    is_entering_syscall = !is_entering_syscall;
                }
            }

            other_status => {
                eprintln!(
                    "[PID {}] Unexpected wait status: {:?}",
                    child_pid, other_status
                );
            }
        }
    }

    eprintln!("---> Tracing finished.");
    Ok(())
}
